<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Manning23"><title>Struts2 Jakarta模块Content-type命令执行漏洞(CVE-2017-5638) · Manning23</title><meta name="description" content="0x00 漏洞简述对于Struts2的RCE漏洞来说，有三个关键点，一个是找到传入ognl的表达式的点，一个是绕过ognl里面的沙盒，一个是尝试理解那些“这tm都调用ognl的函数”。
在struts-default.xml中，Struts2默认处理multipart报文的解析器是jakarta。因"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Manning23</a></h3><div class="description"><p>Technology &amp; Life</p></div></div></div><ul class="social-links"><li><a href="http://weibo.com/2077484845"><i class="fa fa-weibo"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="/images/avatar.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Struts2 Jakarta模块Content-type命令执行漏洞(CVE-2017-5638)</a></h3></div><div class="post-content"><h2 id="0x00-漏洞简述"><a href="#0x00-漏洞简述" class="headerlink" title="0x00 漏洞简述"></a>0x00 漏洞简述</h2><p>对于Struts2的RCE漏洞来说，有三个关键点，一个是找到传入ognl的表达式的点，一个是绕过ognl里面的沙盒，一个是尝试理解那些“这tm都调用ognl的函数”。</p>
<p>在struts-default.xml中，Struts2默认处理multipart报文的解析器是jakarta。因此使用默认的jakarta的版本，便会存在该漏洞。</p>
<h2 id="0x01-漏洞触发原理"><a href="#0x01-漏洞触发原理" class="headerlink" title="0x01 漏洞触发原理"></a>0x01 漏洞触发原理</h2><p>在Strust2中，StrutsPrepareAndExecuteFilter类会默认处理content-type字段。（Jakarta为Struts2上传默认使用库，对上传数据进行解析。）</p>
<p>S2-045 RCE漏洞利用的正是上面这一点。</p>
<p>在Dispatcher.class中，只要content-type含有multipart/form-data便会进入检查流程。</p>
<pre><code>public HttpServletRequest wrapRequest(HttpServletRequest request) throws IOException {
    // don&apos;t wrap more than once
    if (request instanceof StrutsRequestWrapper) {
        return request;
    }

    String content_type = request.getContentType();
    if (content_type != null &amp;&amp; content_type.contains(&quot;multipart/form-data&quot;)) {
        MultiPartRequest mpr = getMultiPartRequest();
        LocaleProvider provider = getContainer().getInstance(LocaleProvider.class);
        request = new MultiPartRequestWrapper(mpr, request, getSaveDir(), provider, disableRequestAttributeValueStackLookup);
    } else {
        request = new StrutsRequestWrapper(request, disableRequestAttributeValueStackLookup);
    }

    return request;
}
</code></pre><p>在FileUploadBase.class类中的FileItemIteratorImpl函数</p>
<pre><code>FileItemIteratorImpl(RequestContext ctx)
            throws FileUploadException, IOException {
        if (ctx == null) {
            throw new NullPointerException(&quot;ctx parameter&quot;);
        }

        String contentType = ctx.getContentType();
        if ((null == contentType)
                || (!contentType.toLowerCase(Locale.ENGLISH).startsWith(MULTIPART))) {
            throw new InvalidContentTypeException(
                    format(&quot;the request doesn&apos;t contain a %s or %s stream, content type header is %s&quot;,
                           MULTIPART_FORM_DATA, MULTIPART_MIXED, contentType));
        }
        ...
</code></pre><p>由于ctx.getContentType()并没有获取到contentType，导致丢出一个异常，而这个异常就是拼接了恶意代码的异常。</p>
<p><img src="/2017/03/08/Struts2-Jakarta模块Content-type命令执行漏洞-CVE-2017-5638/1.png"></p>
<p>而JakartaMultiPartRequest.class类的parse方法的buildErrorMessage函数会调用这个e。</p>
<pre><code>public void parse(HttpServletRequest request, String saveDir) throws IOException {
    try {
        setLocale(request);
        processUpload(request, saveDir);
    } catch (FileUploadBase.SizeLimitExceededException e) {
        if (LOG.isWarnEnabled()) {
            LOG.warn(&quot;Request exceeded size limit!&quot;, e);
        }
        String errorMessage = buildErrorMessage(e, new Object[]{e.getPermittedSize(), e.getActualSize()});
        if (!errors.contains(errorMessage)) {
            errors.add(errorMessage);
        }
    } catch (Exception e) {
        if (LOG.isWarnEnabled()) {
            LOG.warn(&quot;Unable to parse request&quot;, e);
        }
        String errorMessage = buildErrorMessage(e, new Object[]{});
        if (!errors.contains(errorMessage)) {
            errors.add(errorMessage);
</code></pre><p><img src="/2017/03/08/Struts2-Jakarta模块Content-type命令执行漏洞-CVE-2017-5638/2.png"></p>
<p>接下来的调用过程为</p>
<p>buildErrorMessage函数把e带入findText方法。</p>
<pre><code>protected String buildErrorMessage(Throwable e, Object[] args) {
    String errorKey = &quot;struts.messages.upload.error.&quot; + e.getClass().getSimpleName();
    if (LOG.isDebugEnabled()) {
        LOG.debug(&quot;Preparing error message for key: [#0]&quot;, errorKey);
    }
    return LocalizedTextUtil.findText(this.getClass(), errorKey, defaultLocale, e.getMessage(), args);
}
</code></pre><p>LocalizedTextUtil类的findText方法会把e带入到getDefaultMessage函数内，然后进入buildMessageFormat函数。</p>
<pre><code>if (message != null) {
           MessageFormat mf = buildMessageFormat(TextParseUtil.translateVariables(message, valueStack), locale);

           String msg = formatWithNullDetection(mf, args);
           result = new GetDefaultMessageReturnArg(msg, found);
       }
</code></pre><p>先执行buildMessageFormat的TextParseUtil.translateVariables函数</p>
<pre><code>public static String translateVariables(String expression, ValueStack stack) {
    return translateVariables(new char[]{&apos;$&apos;, &apos;%&apos;}, expression, stack, String.class, null).toString();
}
</code></pre><p>然后对 $ 和 % 开头的内容进行搜索，然后都搜索出的内容带入 findValue。</p>
<p><img src="/2017/03/08/Struts2-Jakarta模块Content-type命令执行漏洞-CVE-2017-5638/3.png"></p>
<p>接下来的内容就是绕过ognl的沙盒和拼接更好的利用输出了。</p>
<p>##0x02 Bypass Struts2 2.3.31 ognl沙盒</p>
<p>细心的同学肯定已经发现，此次bypass沙盒的方式显然跟以前不一样，利用中给出现了两次三元表达式，其中第一个三元表达式是进行bypass ognl沙盒的方式。其中运用了两处特性。</p>
<ul>
<li>ognl上下文中存在com.opensymphony.xwork2.ActionContext.container对象。</li>
<li>com.opensymphony.xwork2.ognl.OgnlUtil的实例提供了过于强大的方法。</li>
</ul>
<p>ActionContext.container实例存在getInstance方法。<a href="https://struts.apache.org/maven/struts2-core/apidocs/com/opensymphony/xwork2/inject/Container.html" target="_blank" rel="external">Container</a>，之后便可以利用getInstance方法建立OgnlUtil对象。OgnlUtil类提供了获取和设置的Ognl API。<a href="https://struts.apache.org/maven/struts2-core/apidocs/com/opensymphony/xwork2/ognl/OgnlUtil.html" target="_blank" rel="external">Class OgnlUtil</a> 而其中的 getExcludedClasses() 和 getExcludedPackageNamePatterns() 分别可以获取ognl的禁用的类和禁用的包，这俩方法获取的对象是的数据结构是set，之后调用clear方法便可以清除这些限制内容，导致沙盒失效。</p>
<h2 id="0x03-防护方法"><a href="#0x03-防护方法" class="headerlink" title="0x03 防护方法"></a>0x03 防护方法</h2><p>1，升级Struts至最新版</p>
<p>2，检查content-type内容</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-03-08</span><i class="fa fa-tag"></i></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://yoursite.com/2017/03/08/Struts2-Jakarta模块Content-type命令执行漏洞-CVE-2017-5638/,Manning23,Struts2 Jakarta模块Content-type命令执行漏洞(CVE-2017-5638),;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2017/03/21/Struts2-S046命令执行漏洞/" title="Struts2 S046命令执行漏洞" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2016/05/05/ImageMagic初步分析/" title="ImageMagic初步分析" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>